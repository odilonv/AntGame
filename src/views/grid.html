<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Un pied à l'étrier</title>
    <style>
        body {
            background-color: antiquewhite;
        }
    </style>
</head>

<body>
    <div style="display: flex; gap: 20px; align-items: flex-start;">
        <div style="display: flex; gap: 10px; flex-direction: column;">
            <select id="my_shape">
                <option value="0"> Carré </option>
                <option value="1"> Cercle </option>
            </select>
            <select id="my_color">
                <option value="green"> Vert </option>
                <option value="black"> Noir </option>
                <option value="blue"> Bleu </option>
                <option value="red"> Rouge </option>
            </select>
            <button id="my_button"> Valider </button>
        </div>

        <canvas id="my_canvas"></canvas>
    </div>

    <script type="module">
        import Grid from '../models/grid.js';
        import Agent from '../models/agent.js';

        let size = 15;
        let myGrid = new Grid(size);
        myGrid.drawGrid();


        let _nbLines = myGrid.grid.length; // Nombre d'éléments dans le tableau (nombre de lignes).
        let _nbColumns = myGrid.grid[0].length; // Nombre de colonnes.
        let _cellSize = 50; // La taille d'une cellule en pixel.


        function Display(DrawingFunction) { // Le paramètre DrawingFunction est une fonction.
            for (let i_line = 0; i_line < _nbLines; i_line++) { // Boucles for pour afficher la grille.
                for (let i_col = 0; i_col < _nbColumns; i_col++) {
                    DrawingFunction( // Exécution de la fonction en paramètre (callback).
                        { x: i_col * _cellSize, y: i_line * _cellSize },
                        _cellSize
                    );
                }
            }
        }

        let DrawColoredSquare = function (ctx, shape, color) { // Initialisation de la variable DrawColoredSquare à partir de la déclaration d'une fonction anonyme.
            ctx.fillStyle = color;


            function DrawSquare(startPosition, width) {
                let padding = 2; // Permet d'avoir une ligne entre les carrés de notre grille.
                /* ctx fait référence aux paramètres de la fonction externe */
                ctx.fillRect(startPosition.x, startPosition.y, width - padding, width - padding); // Dessine un carré plein.
            }


            function DrawCircle(startPosition, width) {
                radius = width / 2;
                /* ctx fait référence aux paramètres de la fonction externe */
                ctx.beginPath(); // Nouveau tracé.
                ctx.arc(startPosition.x + radius, startPosition.y + radius, radius, 0, 2 * Math.PI); // Déssiner un cercle.
                ctx.fill(); // Afficher le cercle plein (la fonction stroke pour obtenir un cercle vide).
            }

            /* La fonction renvoyée se souviendra de son environnement et donc du contexte de dessin (ctx) */
            return shape == 0 ? DrawSquare : DrawCircle; // Condition ternaire.
        };


        (function () {
            let canvas = document.getElementById('my_canvas'); // Récupération d'une balise HTML par son ID.
            canvas.width = _nbColumns * _cellSize;
            canvas.height = _nbLines * _cellSize;
            let ctx = canvas.getContext('2d'); // Récupération de la surface de dessin.

            let button = document.getElementById('my_button');
            /* Exécuter une action lors d'un évènement de changement de valeur */
            button.addEventListener('click', function (event) {
                let shape = document.getElementById('my_shape');
                let color = document.getElementById('my_color');
                /* Effet de closure pour la récupération du contexte de dessin */
                ctx.clearRect(0, 0, canvas.width, canvas.height); // Réinitialise en totalité (ou en partie) le canvas (ici en totalité).

                let ColoredSquareFunction = DrawColoredSquare(ctx, shape.value, color.value); // Récupération des value de nos balises <select>.
                Display(ColoredSquareFunction); // Exécuter la fonction Display avec notre fonction issue du return de DrawColoredSquare.
            });
            button.click(); // Trigger l'évènement de click du bouton.
        })();

        let canvas = document.getElementById('my_canvas');
        let tileSize = 128;

        const HEXTILES_IMAGE = new Image();
        HEXTILES_IMAGE.src = 'web/images/tiles/tree.png';

        Promise.all([
            new Promise((resolve) => {
                myGrid.grid[0][0].getTile().addEventListener('load', () => {
                    resolve();
                });
            })
        ])
            .then(() => {
                let ctx = canvas.getContext('2d');

                for (let i = 0; i < _nbLines; i++) {
                    for (let j = 0; j < _nbColumns; j++) {
                        let tileIndex = myGrid.grid[i][j].tile;
                        let sx = 0 * tileSize;
                        let sy = 0;
                        let sWidth = tileSize; // The width of the tile in the image
                        let sHeight = tileSize; // The height of the tile in the image
                        let dx = j * _cellSize; // The x-coordinate on the canvas where the tile should be drawn
                        let dy = i * _cellSize; // The y-coordinate on the canvas where the tile should be drawn
                        let dWidth = _cellSize; // The width of the tile on the canvas
                        let dHeight = _cellSize; // The height of the tile on the canvas

                        ctx.drawImage(myGrid.grid[i][j].getTile(), sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight);
                        if (myGrid.grid[i][j].getType().toString() == "Free") {
                            let ants = myGrid.grid[i][j].ants
                            for (let ant in ants) {
                                let image = new Image();
                                image.src = 'web/images/tiles/ant.png';
                                image.id = "ant"
                                image.addEventListener('load', () => {
                                    ctx.drawImage(image, dx, dy, 20, 20);
                                });

                                setInterval(() => {
                                    let canvas = document.getElementById('ant');
                                    let ctx = canvas.getContext('2d');
                                    ctx.moveTo(ant.x, ant.y);
                                }, 1000);
                            }
                        }
                    }
                }
            });


        /*
            Exercice 1:
            -----------
            A l'aide de la fonction ctx.drawImage (https://developer.mozilla.org/fr/docs/Web/API/CanvasRenderingContext2D/drawImage) afficher une grille d'images.
            Les valeurs au sein de la grille déterminent l'image à afficher.
            Utiliser pour cela:

            * la grille suivante:

            let _grid = [
                [0, 0, 0],
                [0, 1, 0],
                [0, 2, 0],
                [0, 0, 0],
            ];

            * les trois premières tuiles de 32px (en ligne) issues de l'image TP_AntAlgorithm/tiles/foodAndColony.png.
            * le code suivant pour charger le png et écrire votre programme.

            ```
            const HEXTILES_IMAGE = new Image();
            HEXTILES_IMAGE.src = 'path/of/png';
            Promise.all([
                new Promise( (resolve) => {HEXTILES_IMAGE.addEventListener('load', () => { resolve();}); })
            ])
            .then(() => {
                // Votre code ici.
            });
            ```

            ########################################################

            Exercice 2:
            -----------
            Effectuer ce même exercice à travers l'architecture MVC (https://github.com/PAJEAN/cours_javascript/tree/master/TP/MVC) en utilisant des fonctions callback entre les classes.
        */
    </script>

</body>

</html>